@page "/timeline/{timelinetype}" 
@page "/timeline/{timelinetype}/{username}"
@using Newtonsoft.Json;
@using MiniTwitApi.Shared.Models;
@using MiniTwitApi.Shared.Models.UserModels;
@using System.Globalization
@using System.Text
@using MiniTwitApi.Shared
@using System.Text.Json;

@inject HttpClient httpClient
@inject IJSRuntime JSRuntime

@if(@TimelineType.Contains("public"))
{
    <h2>Public Timeline</h2>
}
else if(@TimelineType.Contains("user_timeline"))
{
    <h2>@Username's Timeline</h2>
}
else if(@TimelineType.Contains("mytimeline"))
{
    <h2>My timeline</h2>
}

@if(ErrorRaised)
{
    <div class="error"><strong>Error:</strong> @ErrorMessage</div>
}

@if(CurrentLoggedInUser is not null)
{
    @if(@TimelineType.Contains("user_timeline"))
    {
        <div class=followstatus>
            @if (async () => await GetUser().Username.Equals(Username))
            {
                <p>This is you!</p>
            }
            else if (IsFollowed()) @*Should check if the user which posted the messaged is followed by the viewing user, must be done via API?*@
            {
                <p>You are currently following this user.</p>
                <a class=unfollow href="@UnfollowUser()">Unfollow user</a> @*Implement unfollowing user*@
            }
            else
            {
                <p>You are not yet following this user.</p>
                <a class=follow href="@FollowUser()">Follow user</a> @*Implement following user*@
            }
        </div>
    }
    else if(@TimelineType.Contains("mytimeline"))
    {
        <div class=twitbox>
            <h3>What's on your mind @CurrentLoggedInUser.Username?</h3>
            <EditForm Model="@PostDTO" OnValidSubmit="@PostMessage">
                <DataAnnotationsValidator />
                <ValidationSummary />
                <InputText @bind-Value="PostDTO.Content" />
                <button type="submit" class="btn btn-primary">Share</button>
            </EditForm>
        </div>
    }
}

<Messages messages="@messageList" />

@code{
    [Parameter]    
    public string TimelineType {get;set;}
    [Parameter]
    public string Username { get; set;}
    
    public UserDTO CurrentLoggedInUser;
    private bool ErrorRaised = false;
    private string ErrorMessage;

    private MessageToPost PostDTO = new MessageToPost();

    Dictionary<MessageDTO, UserDTO> messageList = new Dictionary<MessageDTO, UserDTO>();

    protected override async Task OnInitializedAsync()
    {
        var json = await JSRuntime.InvokeAsync<string>("getUser");
        CurrentLoggedInUser = JsonConvert.DeserializeObject<UserDTO>(json);
        
        ICollection<MessageDTO> messages = new List<MessageDTO>();
        try
        {
            var responseJson = await httpClient.GetStringAsync("/msgs/?no=20");
            messages = JsonConvert.DeserializeObject<List<MessageDTO>>(responseJson);
        }
        catch(Exception e)
        {
            ErrorRaised = true;
            ErrorMessage = e.Message;
        }

        foreach(var m in messages)
        {   
            UserDTO user = new UserDTO();
            var responseJson = await httpClient.GetStringAsync($"/user/{m.Author}");
            user = JsonConvert.DeserializeObject<UserDTO>(responseJson);
            messageList.Add(m, user);
        }
    }

    //TODO IsFollowedBy should be an Endpoint
    public async Task<bool> IsFollowed()
    {
        var response = await httpClient.GetStringAsync($"$follws/{CurrentLoggedInUser.Username}");
        var followers = JsonConvert.DeserializeObject<List<FollowerDTO>>(response);
        foreach (var follower in followers)
        {
            var getUser = await httpClient.GetStringAsync($"/user/{follower.WhomId}");
            var jsonUser = JsonConvert.DeserializeObject<UserDTO>(getUser);
            if (jsonUser.Username.Equals(Username))
                return true;
        }
        return false;
    }

    public async Task FollowUser()
    {
        var json = System.Text.Json.JsonSerializer.Serialize(new Follow()
        {
            ToFollow = Username
        });
        var data = new StringContent(json, Encoding.UTF8, "application/json");
        var response = await httpClient.PostAsync($"/fllws", data);
        //Handle Errors
    }
    
    public async Task UnfollowUser()
    {
        var json = System.Text.Json.JsonSerializer.Serialize(new Follow()
        {
            ToUnfollow = Username
        });
        var data = new StringContent(json, Encoding.UTF8, "application/json");
        var response = await httpClient.PostAsync($"/fllws", data);
        //Handle Errors
    }

    public async Task<UserDTO> GetUser()
    {
        var user = await JSRuntime.InvokeAsync<string>("GetUser");
        return System.Text.Json.JsonSerializer.Deserialize<UserDTO>(user);
    }

    //Retrieved from https://www.thecodebuzz.com/convert-unix-epoch-time-to-datetime-and-date-to-unix-datecsharp-net/
    public DateTime GenerateDateTime(int date)
    {
        DateTimeOffset dateTimeOffSet = DateTimeOffset.FromUnixTimeMilliseconds(date);
        return dateTimeOffSet.DateTime;
    }

    private async Task PostMessage()
    {
        var json = JsonConvert.SerializeObject(PostDTO);
        var data = new StringContent(json, Encoding.UTF8, "application/json");

        string linkToPostTo = "/msgs/"+CurrentLoggedInUser.Username;
    
        try
        {
            var response = await httpClient.PostAsync(linkToPostTo, data);
            var result = response.Content.ReadAsStringAsync().Result;
            Console.WriteLine(result);
        }
        catch (Exception e)
        {
            ErrorRaised = true;
            ErrorMessage = e.Message;
        }
    }
}