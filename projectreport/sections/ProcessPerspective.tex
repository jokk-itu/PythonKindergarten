\section{Process' perspective}

\textbf{Interactions as developers}\newline
 How do you interact as developers?\newline
 
\newline
\textbf{Team organization}\newline
  How is the team organized?\newline
  \begin{itemize}
  \item A complete description of stages and tools included in the CI/CD chains.(That is, including deployment and release of your systems.)
  \item Organization of your repositor(ies).(That is, either the structure of of mono-repository or organization of artifacts across repositories. --> In essence, it has to be be clear what is stored where and why.)
  \item Applied branching strategy.
  \item Applied development process and tools supporting it (For example, how did you use issues, Kanban boards, etc. to organize open tasks)
  \subsection{System monitoring}
  \subsubsection{How are the system monitored (Change section title)}
  Monitoring of our system is done using Prometheus and Grafana, deployed using docker-compose. \newline
  Prometheus acts as a data collector, periodically scraping metrics from configured targets and storing the collected data in the built-in local time series database.\newline
  Our system consists of two docker nodes, a master and a worker, which are both configured as targets in our Prometheus deployment.\newline
  By configuring our Prometheus server as a datasource within Grafana, the stored time series data can be visualized in Grafana dashboards. Our metrics are visualized in two separate dashboards, accessible through the Grafana web interface.

  \subsubsection{What are the monitored metrics (Change section title)}
  To expose metrics in our system we use a NuGet package called prometheus-net (https://github.com/prometheus-net/prometheus-net).
  This package allows us to expose metrics on the /metrics endpoint, which can then be scraped and stored by Prometheus.
  \newline
  To extend the default metrics provided by prometheus-net, we use two additional packages: 
  prometheus-net.DotNetMetrics (https://github.com/djluck/prometheus-net.DotNetRuntime) and prometheus-net.AspNet (https://github.com/rocklan/prometheus-net.AspNet).
  \newline
  The DotNetMetrics package provides us with general dotnet metrics, such as GC, byte allocation, lock contention and exceptions.
  \newline
  The AspNet package provides us with ASP.NET specific metrics, such as requests/sec, request duration and error rates.
  \newline
  \newline
  Snapshots of our two dashboards are publicly available on the following links:
  \newline
  Dotnet metrics: https://tinyurl.com/pythonkindergarten-dotnet
  \newline
  ASP.NET (api-specific) metrics: https://tinyurl.com/pythonkindergarten-aspnet
  \item What do you log in your systems and how do you aggregate logs?
  \item Brief results of the security assessment.
  \subsection{System Scaling and load-balancing}
  \subsubsection{Scaling}
  We have applied both scaling (using docker swarm) and load-balancing (using Digital Ocean Load Balancer) in our system. 
  Our Docker swarm consists of two servers, a master node and a dedicated worker node, each running multiple service replicas. 
  These two server are internally load-balancing using the Docker mesh network and only one node has to be known, in order to communicate with the swarm.

  \subsubsection{Load-Balancing}
  There might be situations where every known swarm node is down, in which case the system as a whole might be unreachable, even though there might still be running nodes in the swarm.
  \newline
  To mitigate this, we use a Digital Ocean Load Balancer. This acts as a gateway (single entry-point) to our Docker swarm, balancing the load between each of our servers and executing health checks, which ensures that the client is always connected to a reachable swarm node.
  \newline
  As an added bonus, the load balancer masks the ips of our servers from clients, making our system less prone to hackers.

  \newline
  \newline
  \newline
  Using these strategies we are able to scale far beyond our current setup, simply by joining more servers to our swarm and configuring these in the DO load balancer.\newline
  The only caveat is that our database is currently running on a single server, but could be migrated to a database cluster on Digital Ocean, AWS, Google Cloud or similar cloud providers.
  \item In essence it has to be clear how code or other artifacts come from idea into the running system and everything that happens on the way.
  
\end{itemize}